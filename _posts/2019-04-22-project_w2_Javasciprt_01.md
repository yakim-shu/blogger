---
title: "[第二週] 基礎 JavaScript - 邏輯、位元運算"
layout: post
description: "回憶起大四的時候去學校圖書館找 JavaScript 的書（ 而當時的我借到的其實是 Java 的事就不提了... ），其他的運算子都非常好懂，直到翻開位元運算的那一篇。"
category: project
image: 
tags: [CLI, project]
file_name: 2019-04-22-project_w2_Javasciprt_01
---

## 介紹 Node.js

Node.js 是一個 JavaScript 的執行環境。

在 Node.js 出現之前，JavaScript 只能在瀏覽器上運行，Node.js 就是提供 Javascript 除了瀏覽器以外的運行環境。

- 執行方法： 
    - `node <file-name>` 
    - 或是直接執行 `node`，再輸入你的程式

---

### 題外話小技巧

- 如何快速打開 VScode
    - 先照此教學安裝指令： [如何以 CLI 啟動 VS Code ?](https://oomusou.io/vscode/cli/)
        - 以後要在 Terminal 快速開啟 VScode 就簡單了！
    - `code .` ： 新增工作目錄
    - `code <file-name>` ： 開啟檔案
- 快速開啟瀏覽器的開發人員工具 
    - 快捷鍵： `option` + `cmd` + `i`

---

### 基本邏輯的短路性質

以前對於 `||`、`&&` 邏輯運算子的看法是，不就是以前國中學過的嗎？這麼簡單有什麼好講的，但當時看 JavaScript 犀牛書的時候不禁讚嘆：「 原來還可以這樣？！ 」，不過這節還是補充了以前不知道的資訊，太好了！

> 注意

在 JavaScript 裡，代表 `false` 的就只有幾個： `0`、`-0`、`NaN`、`null`、`undefined`、`""` ( ← 空字串 )，**所以搞清楚 `false` 還蠻重要的喔**，不然往後的日子應該有很多坑可以跳。

剛好複習一下當時的筆記： 
- [Javascript大全 - 01 型別、值與變數](https://yakimhsu.com/javascript/JS_Daquan-01.html) 
- [Javascript大全 - 02 運算式與運算子](https://yakimhsu.com/javascript/JS_Daquan-02.html)

---

### ` || ` 邏輯運算子 OR
- 只要找到第一個 `true`，會回傳 `true` 的值，**不再繼續查找後面的值**。
- 全部都為 `false`，會**回傳最後一個為 `false` 的值**
   
```javascript
undefined || 0 || "hello" || false  // 找到 true 回傳
> "hello"
NaN || 0 || undefined || "" || null // 全部都為 false，回傳最後一個 false 的值
> null
```

### ` && ` 邏輯運算子 AND
- 只要找到第一個 `false`，會回傳 `false` 的值，**不再繼續查找後面的值**。
- 全部都為 `true`，會**回傳最後一個為 `true` 的值**
    
```javascript
"hello" && 10 && "" && 1 // 找到 false 回傳
> ""
10 && "world" && 1 // 全部都為 true，回傳最後一個 true 的值
> 1
```

---

## 位元運算

位元運算真的很有趣，今天整個下午都花在這了，吳鎮宇說的沒錯：「 出來混，遲早要還的 」一度逃避的東西還是被默默回來找你。

大四的時候很想學網頁，學姊跟我說：「可以去看 JavaScript。」，然後就去了學校圖書館找 JavaScript 的書，其他的運算子都非常好懂，直到翻開位元運算的那一頁，就沒有再翻過下一頁了。（ 而且後來才發現我借到 Java... ）

（ 回到正題，跳一下 ）

要了解什麼是位元運算，首先要介紹**位元位移**，要知道什麼是位元位移，首先要有 **2 進位**的觀念。

（ 不難、先不要崩潰 ）

2^i   | 2⁵  | 2⁴  | 2³  | 2²  | 2¹  | 2⁰  | 數字
----- | --- | --- | --- | --- | --- | --- | --- 
值     | 32  | 16  | 8   | 4   | 2   | 1   |
範例 A | 0   | 1   | 1   | 0   | 1   | 0   | 16+8+2 = 26
範例 B | 1   | 0   | 0   | 1   | 0   | 1   | 32+4+1 = 37
 
 意思是說 `26` 的二進制表示法為 `011010` 、 `37` 的二進制表示法為 `100101`。

---

## `>>` 、 `<<` 位元位移 
- 假如任意數字 `n` 為上面的範例 A ：`011010` → `26`

### `>>` 位元右移
- `n >> i` ： `n` 除以 `2 的 i 次方` 
    - `n >> 1`： 往右移 1 位：等於 `n / 2`
    - `n >> 2`： 往右移 2 位：等於 `n / 4`

### `<<` 位元左移 
- `n << i` ： `n` 乘以 `2 的 i 次方` 
    - `n << 1`： 往左移 1 位：等於 `n * 2`
    - `n << 2`： 往左移 2 位：等於 `n * 4`

```
// 往左位移（ 後面補 0 ）
A: 011010 << 1 → 0110100 // 等於 26 << 1 等於 26 * 2 == 52
A: 011010 << 2 → 01101000 // 等於 26 << 2 等於 26 * 4 == 104

// 往右位移（ 後面直接捨去 ）
A: 011010 >> 1 → 001101 // 等於 26 >> 1 等於 26 / 2 == 13
A: 011010 >> 2 → 000110 // 等於 26 >> 2 等於 26 / 4 == 6 ( 餘數無條件捨去 )
```

那這樣很不直覺的運算到底能幹嘛呢？ 

答案是在**效能**上有所差異，因為電腦只認得二進制的機器碼，所以照理來說，同樣得出 `n * 2` 的運算結果，`n << 1` 會比   `n * 2` 還要來得快。

---

### `|` 、 `&` 、 `^` 位元運算子

> 注意：

不要把位元運算子 **`|`、`&`** 跟邏輯運算子 **`||`、`&&`** 搞混了，可以把位元運算子理解成 **2 進位版的邏輯比較**。

---

### `|` 位元 OR

當成位元間的 `||`，以 `0011 | 1001` ( `3 | 9` ) 為例，會回傳 `1011` ( `11` )

`|` 運算結果 | 1   | 0   | 1   | 1   | 11
----------- | --- | --- | --- | --- | --- 
範例 A       | 0   | 0   | 1   | 1  | 3
範例 B       | 1   | 0   | 0   | 1  | 9

可以拆解成以下步驟：  

```
- 2^3 → 0 || 1 → 1 
- 2^2 → 0 || 0 → 0 
- 2^1 → 1 || 0 → 1 
- 2^0 → 1 || 1 → 1
```

---

### `&` 位元 AND

當成位元間的 `&&`，以 `0011 & 1001` ( `3 & 9` ) 為例，會回傳 `0001`( `1` )

`&` 運算結果 | 0   | 0   | 0   | 1   | 1
----------- | --- | --- | --- | --- | --- 
範例 A       | 0   | 0   | 1   | 1  | 3
範例 B       | 1   | 0   | 0   | 1  | 9

可以拆解成以下步驟：  
```
- 2^3 → 0 && 1 → 0 
- 2^2 → 0 && 0 → 0 
- 2^1 → 1 && 0 → 0 
- 2^0 → 1 && 1 → 1
```

---

### `^` 位元 XOR

**最特別的一種，只有當兩邊是一樣的**：`0 ^ 0` 和 `1 ^ 1` 的時候才會**回傳 `0`**。

同樣以 `0011 ^ 1001` ( `3 ^ 9` ) 為例，會回傳 `1010`( `10` )

`^` 運算結果 | 1   | 0   | 1   | 0   | 10
----------- | --- | --- | --- | --- | --- 
範例 A       | 0   | 0   | 1   | 1  | 3
範例 B       | 1   | 0   | 0   | 1  | 9

可以拆解成以下步驟： 

```
- 2^3 → 0 ^ 1 → 1 
- 2^2 → 0 ^ 0 → 0 
- 2^1 → 1 ^ 0 → 1 
- 2^0 → 1 ^ 1 → 0
```

> 注意：
上面的 `2^3`，是為了方便表示 **2 的 3 平方**，不要跟 **^ 位元運算子**搞混了。

---

## 應用

又回到每天都要問的問題，所以到底能幹嘛勒？！

做個小實驗，把任意數字 `n` 跟 `1` 做 `&` 位元運算會發生什麼事？

- `n & 1` → `1` ，代表 `n` 的最後 1 個位元數 ( 2⁰ ) 是 `1`
- `n & 1` → `0` ，代表 `n` 的最後 1 個位元數 ( 2⁰ ) 是 `0`

> 猜出來了嗎？將 `n & 1` 是**判斷 `n` 是奇數 or 偶數**的小技巧。除了使用 `n % 2` " 取餘數 " 的傳統方式，`n & 1` 是個效能更好的方法。

```
10 & 1 → 0 // 偶數
11 & 1 → 1 // 奇數
```

---

再把任意數字 `n` 跟 `2的任意平方` 做 `&` 位元運算會發生什麼事？

- `n & 4` → `1` ，代表 `n` 的倒數第 3 個位元數 ( 2² ) 是 `1`
- `n & 4` → `0` ，代表 `n` 的倒數第 3 個位元數 ( 2² ) 是 `0`
- ... 
- 以此類推下去，有點類似**遮罩**的概念

---

## 結論

本章學到兩個**效能更好的實用小技巧**，稍微複習一下：

- `n >> 1` 效果如同 `n / 2`
- `n << 1` 效果如同 `n * 2`
- `n & 1` 效果如同 `n % 2` → `1` ， 代表 `n` 為 `奇數`
- `n & 1` 效果如同 `n % 2` → `0` ， 代表 `n` 為 `偶數`




